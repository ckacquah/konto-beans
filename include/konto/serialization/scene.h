// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCENE_KONTO_SERIALIZABLE_H_
#define FLATBUFFERS_GENERATED_SCENE_KONTO_SERIALIZABLE_H_

#include <flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 1 && FLATBUFFERS_VERSION_REVISION == 21,
              "Non-compatible flatbuffers version included");

#include "components.h"

namespace Konto
{
namespace Serializable
{

struct Entity;
struct EntityBuilder;

struct Scene;
struct SceneBuilder;

struct Entity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef EntityBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ID = 4,
        VT_NAME = 6,
        VT_COMPONENTS_TYPE = 8,
        VT_COMPONENTS = 10
    };
    uint64_t id() const
    {
        return GetField<uint64_t>(VT_ID, 0);
    }
    const ::flatbuffers::String* name() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_NAME);
    }
    const ::flatbuffers::Vector<uint8_t>* components_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_COMPONENTS_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* components() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>>*>(VT_COMPONENTS);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_ID, 8) &&
               VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_COMPONENTS_TYPE) && verifier.VerifyVector(components_type()) &&
               VerifyOffset(verifier, VT_COMPONENTS) && verifier.VerifyVector(components()) &&
               VerifyComponentVector(verifier, components(), components_type()) && verifier.EndTable();
    }
};

struct EntityBuilder
{
    typedef Entity Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_id(uint64_t id)
    {
        fbb_.AddElement<uint64_t>(Entity::VT_ID, id, 0);
    }
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(Entity::VT_NAME, name);
    }
    void add_components_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> components_type)
    {
        fbb_.AddOffset(Entity::VT_COMPONENTS_TYPE, components_type);
    }
    void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> components)
    {
        fbb_.AddOffset(Entity::VT_COMPONENTS, components);
    }
    explicit EntityBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Entity> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Entity>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Entity> CreateEntity(
    ::flatbuffers::FlatBufferBuilder& _fbb, uint64_t id = 0, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> components_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> components = 0)
{
    EntityBuilder builder_(_fbb);
    builder_.add_id(id);
    builder_.add_components(components);
    builder_.add_components_type(components_type);
    builder_.add_name(name);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Entity> CreateEntityDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, uint64_t id = 0, const char* name = nullptr,
    const std::vector<uint8_t>* components_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>>* components = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto components_type__ = components_type ? _fbb.CreateVector<uint8_t>(*components_type) : 0;
    auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*components) : 0;
    return Konto::Serializable::CreateEntity(_fbb, id, name__, components_type__, components__);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SceneBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NAME = 4,
        VT_ENTITIES = 6
    };
    const ::flatbuffers::String* name() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_NAME);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Konto::Serializable::Entity>>* entities() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Konto::Serializable::Entity>>*>(
            VT_ENTITIES);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_ENTITIES) && verifier.VerifyVector(entities()) &&
               verifier.VerifyVectorOfTables(entities()) && verifier.EndTable();
    }
};

struct SceneBuilder
{
    typedef Scene Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(Scene::VT_NAME, name);
    }
    void add_entities(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Konto::Serializable::Entity>>> entities)
    {
        fbb_.AddOffset(Scene::VT_ENTITIES, entities);
    }
    explicit SceneBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Scene> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Scene>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Scene> CreateScene(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Konto::Serializable::Entity>>> entities = 0)
{
    SceneBuilder builder_(_fbb);
    builder_.add_entities(entities);
    builder_.add_name(name);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Scene> CreateSceneDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const char* name = nullptr,
    const std::vector<::flatbuffers::Offset<Konto::Serializable::Entity>>* entities = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto entities__ = entities ? _fbb.CreateVector<::flatbuffers::Offset<Konto::Serializable::Entity>>(*entities) : 0;
    return Konto::Serializable::CreateScene(_fbb, name__, entities__);
}

inline const Konto::Serializable::Scene* GetScene(const void* buf)
{
    return ::flatbuffers::GetRoot<Konto::Serializable::Scene>(buf);
}

inline const Konto::Serializable::Scene* GetSizePrefixedScene(const void* buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<Konto::Serializable::Scene>(buf);
}

inline bool VerifySceneBuffer(::flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<Konto::Serializable::Scene>(nullptr);
}

inline bool VerifySizePrefixedSceneBuffer(::flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<Konto::Serializable::Scene>(nullptr);
}

inline void FinishSceneBuffer(::flatbuffers::FlatBufferBuilder& fbb,
                              ::flatbuffers::Offset<Konto::Serializable::Scene> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedSceneBuffer(::flatbuffers::FlatBufferBuilder& fbb,
                                          ::flatbuffers::Offset<Konto::Serializable::Scene> root)
{
    fbb.FinishSizePrefixed(root);
}

} // namespace Serializable
} // namespace Konto

#endif // FLATBUFFERS_GENERATED_SCENE_KONTO_SERIALIZABLE_H_
