// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_
#define FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_

#include <flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 1 && FLATBUFFERS_VERSION_REVISION == 21,
              "Non-compatible flatbuffers version included");

namespace Konto
{
namespace Serializable
{

struct Vec3;

struct Color;

struct Transform;

struct Camera;

struct SpriteRenderer;
struct SpriteRendererBuilder;

struct CircleRenderer;
struct CircleRendererBuilder;

enum Component : uint8_t
{
    Component_NONE = 0,
    Component_Transform = 1,
    Component_Camera = 2,
    Component_SpriteRenderer = 3,
    Component_CircleRenderer = 4,
    Component_MIN = Component_NONE,
    Component_MAX = Component_CircleRenderer
};

inline const Component (&EnumValuesComponent())[5]
{
    static const Component values[] = {Component_NONE, Component_Transform, Component_Camera, Component_SpriteRenderer,
                                       Component_CircleRenderer};
    return values;
}

inline const char* const* EnumNamesComponent()
{
    static const char* const names[6] = {"NONE", "Transform", "Camera", "SpriteRenderer", "CircleRenderer", nullptr};
    return names;
}

inline const char* EnumNameComponent(Component e)
{
    if (::flatbuffers::IsOutRange(e, Component_NONE, Component_CircleRenderer))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesComponent()[index];
}

template <typename T> struct ComponentTraits
{
    static const Component enum_value = Component_NONE;
};

template <> struct ComponentTraits<Konto::Serializable::Transform>
{
    static const Component enum_value = Component_Transform;
};

template <> struct ComponentTraits<Konto::Serializable::Camera>
{
    static const Component enum_value = Component_Camera;
};

template <> struct ComponentTraits<Konto::Serializable::SpriteRenderer>
{
    static const Component enum_value = Component_SpriteRenderer;
};

template <> struct ComponentTraits<Konto::Serializable::CircleRenderer>
{
    static const Component enum_value = Component_CircleRenderer;
};

bool VerifyComponent(::flatbuffers::Verifier& verifier, const void* obj, Component type);
bool VerifyComponentVector(::flatbuffers::Verifier& verifier,
                           const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values,
                           const ::flatbuffers::Vector<uint8_t>* types);

enum ProjectionType : int32_t
{
    ProjectionType_PERSPECTIVE = 0,
    ProjectionType_ORTHOGRAPHIC = 1,
    ProjectionType_MIN = ProjectionType_PERSPECTIVE,
    ProjectionType_MAX = ProjectionType_ORTHOGRAPHIC
};

inline const ProjectionType (&EnumValuesProjectionType())[2]
{
    static const ProjectionType values[] = {ProjectionType_PERSPECTIVE, ProjectionType_ORTHOGRAPHIC};
    return values;
}

inline const char* const* EnumNamesProjectionType()
{
    static const char* const names[3] = {"PERSPECTIVE", "ORTHOGRAPHIC", nullptr};
    return names;
}

inline const char* EnumNameProjectionType(ProjectionType e)
{
    if (::flatbuffers::IsOutRange(e, ProjectionType_PERSPECTIVE, ProjectionType_ORTHOGRAPHIC))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesProjectionType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS
{
  private:
    float x_;
    float y_;
    float z_;

  public:
    Vec3() : x_(0), y_(0), z_(0)
    {
    }
    Vec3(float _x, float _y, float _z)
        : x_(::flatbuffers::EndianScalar(_x)), y_(::flatbuffers::EndianScalar(_y)), z_(::flatbuffers::EndianScalar(_z))
    {
    }
    float x() const
    {
        return ::flatbuffers::EndianScalar(x_);
    }
    float y() const
    {
        return ::flatbuffers::EndianScalar(y_);
    }
    float z() const
    {
        return ::flatbuffers::EndianScalar(z_);
    }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS
{
  private:
    float r_;
    float g_;
    float b_;
    float a_;

  public:
    Color() : r_(0), g_(0), b_(0), a_(0)
    {
    }
    Color(float _r, float _g, float _b, float _a)
        : r_(::flatbuffers::EndianScalar(_r)), g_(::flatbuffers::EndianScalar(_g)), b_(::flatbuffers::EndianScalar(_b)),
          a_(::flatbuffers::EndianScalar(_a))
    {
    }
    float r() const
    {
        return ::flatbuffers::EndianScalar(r_);
    }
    float g() const
    {
        return ::flatbuffers::EndianScalar(g_);
    }
    float b() const
    {
        return ::flatbuffers::EndianScalar(b_);
    }
    float a() const
    {
        return ::flatbuffers::EndianScalar(a_);
    }
};
FLATBUFFERS_STRUCT_END(Color, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    int8_t padding0__;
    int16_t padding1__;
    Konto::Serializable::Vec3 scale_;
    Konto::Serializable::Vec3 rotation_;
    Konto::Serializable::Vec3 translation_;

  public:
    Transform() : enabled_(0), padding0__(0), padding1__(0), scale_(), rotation_(), translation_()
    {
        (void)padding0__;
        (void)padding1__;
    }
    Transform(bool _enabled, const Konto::Serializable::Vec3& _scale, const Konto::Serializable::Vec3& _rotation,
              const Konto::Serializable::Vec3& _translation)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))), padding0__(0), padding1__(0),
          scale_(_scale), rotation_(_rotation), translation_(_translation)
    {
        (void)padding0__;
        (void)padding1__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    const Konto::Serializable::Vec3& scale() const
    {
        return scale_;
    }
    const Konto::Serializable::Vec3& rotation() const
    {
        return rotation_;
    }
    const Konto::Serializable::Vec3& translation() const
    {
        return translation_;
    }
};
FLATBUFFERS_STRUCT_END(Transform, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Camera FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    uint8_t primary_;
    uint8_t fixed_aspect_ratio_;
    int8_t padding0__;
    float aspect_ratio_;
    float perspective_far_;
    float perspective_near_;
    float perspective_fov_;
    float orthographic_far_;
    float orthographic_near_;
    float orthographic_size_;
    int32_t projection_type_;

  public:
    Camera()
        : enabled_(0), primary_(0), fixed_aspect_ratio_(0), padding0__(0), aspect_ratio_(0), perspective_far_(0),
          perspective_near_(0), perspective_fov_(0), orthographic_far_(0), orthographic_near_(0), orthographic_size_(0),
          projection_type_(0)
    {
        (void)padding0__;
    }
    Camera(bool _enabled, bool _primary, bool _fixed_aspect_ratio, float _aspect_ratio, float _perspective_far,
           float _perspective_near, float _perspective_fov, float _orthographic_far, float _orthographic_near,
           float _orthographic_size, Konto::Serializable::ProjectionType _projection_type)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))),
          primary_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_primary))),
          fixed_aspect_ratio_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_fixed_aspect_ratio))), padding0__(0),
          aspect_ratio_(::flatbuffers::EndianScalar(_aspect_ratio)),
          perspective_far_(::flatbuffers::EndianScalar(_perspective_far)),
          perspective_near_(::flatbuffers::EndianScalar(_perspective_near)),
          perspective_fov_(::flatbuffers::EndianScalar(_perspective_fov)),
          orthographic_far_(::flatbuffers::EndianScalar(_orthographic_far)),
          orthographic_near_(::flatbuffers::EndianScalar(_orthographic_near)),
          orthographic_size_(::flatbuffers::EndianScalar(_orthographic_size)),
          projection_type_(::flatbuffers::EndianScalar(static_cast<int32_t>(_projection_type)))
    {
        (void)padding0__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    bool primary() const
    {
        return ::flatbuffers::EndianScalar(primary_) != 0;
    }
    bool fixed_aspect_ratio() const
    {
        return ::flatbuffers::EndianScalar(fixed_aspect_ratio_) != 0;
    }
    float aspect_ratio() const
    {
        return ::flatbuffers::EndianScalar(aspect_ratio_);
    }
    float perspective_far() const
    {
        return ::flatbuffers::EndianScalar(perspective_far_);
    }
    float perspective_near() const
    {
        return ::flatbuffers::EndianScalar(perspective_near_);
    }
    float perspective_fov() const
    {
        return ::flatbuffers::EndianScalar(perspective_fov_);
    }
    float orthographic_far() const
    {
        return ::flatbuffers::EndianScalar(orthographic_far_);
    }
    float orthographic_near() const
    {
        return ::flatbuffers::EndianScalar(orthographic_near_);
    }
    float orthographic_size() const
    {
        return ::flatbuffers::EndianScalar(orthographic_size_);
    }
    Konto::Serializable::ProjectionType projection_type() const
    {
        return static_cast<Konto::Serializable::ProjectionType>(::flatbuffers::EndianScalar(projection_type_));
    }
};
FLATBUFFERS_STRUCT_END(Camera, 36);

struct SpriteRenderer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SpriteRendererBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ENABLED = 4,
        VT_TEXTURE_PATH = 6,
        VT_COLOR = 8,
        VT_TILING_FACTOR = 10
    };
    bool enabled() const
    {
        return GetField<uint8_t>(VT_ENABLED, 0) != 0;
    }
    const ::flatbuffers::String* texture_path() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_TEXTURE_PATH);
    }
    const Konto::Serializable::Color* color() const
    {
        return GetStruct<const Konto::Serializable::Color*>(VT_COLOR);
    }
    float tiling_factor() const
    {
        return GetField<float>(VT_TILING_FACTOR, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
               VerifyOffset(verifier, VT_TEXTURE_PATH) && verifier.VerifyString(texture_path()) &&
               VerifyField<Konto::Serializable::Color>(verifier, VT_COLOR, 4) &&
               VerifyField<float>(verifier, VT_TILING_FACTOR, 4) && verifier.EndTable();
    }
};

struct SpriteRendererBuilder
{
    typedef SpriteRenderer Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_enabled(bool enabled)
    {
        fbb_.AddElement<uint8_t>(SpriteRenderer::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
    }
    void add_texture_path(::flatbuffers::Offset<::flatbuffers::String> texture_path)
    {
        fbb_.AddOffset(SpriteRenderer::VT_TEXTURE_PATH, texture_path);
    }
    void add_color(const Konto::Serializable::Color* color)
    {
        fbb_.AddStruct(SpriteRenderer::VT_COLOR, color);
    }
    void add_tiling_factor(float tiling_factor)
    {
        fbb_.AddElement<float>(SpriteRenderer::VT_TILING_FACTOR, tiling_factor, 0.0f);
    }
    explicit SpriteRendererBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SpriteRenderer> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SpriteRenderer>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SpriteRenderer> CreateSpriteRenderer(
    ::flatbuffers::FlatBufferBuilder& _fbb, bool enabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> texture_path = 0, const Konto::Serializable::Color* color = nullptr,
    float tiling_factor = 0.0f)
{
    SpriteRendererBuilder builder_(_fbb);
    builder_.add_tiling_factor(tiling_factor);
    builder_.add_color(color);
    builder_.add_texture_path(texture_path);
    builder_.add_enabled(enabled);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<SpriteRenderer> CreateSpriteRendererDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, bool enabled = false, const char* texture_path = nullptr,
    const Konto::Serializable::Color* color = nullptr, float tiling_factor = 0.0f)
{
    auto texture_path__ = texture_path ? _fbb.CreateString(texture_path) : 0;
    return Konto::Serializable::CreateSpriteRenderer(_fbb, enabled, texture_path__, color, tiling_factor);
}

struct CircleRenderer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef CircleRendererBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ENABLED = 4,
        VT_TEXTURE_PATH = 6,
        VT_COLOR = 8,
        VT_FADE = 10,
        VT_THICKNESS = 12
    };
    bool enabled() const
    {
        return GetField<uint8_t>(VT_ENABLED, 0) != 0;
    }
    const ::flatbuffers::String* texture_path() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_TEXTURE_PATH);
    }
    const Konto::Serializable::Color* color() const
    {
        return GetStruct<const Konto::Serializable::Color*>(VT_COLOR);
    }
    float fade() const
    {
        return GetField<float>(VT_FADE, 0.0f);
    }
    float thickness() const
    {
        return GetField<float>(VT_THICKNESS, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
               VerifyOffset(verifier, VT_TEXTURE_PATH) && verifier.VerifyString(texture_path()) &&
               VerifyField<Konto::Serializable::Color>(verifier, VT_COLOR, 4) &&
               VerifyField<float>(verifier, VT_FADE, 4) && VerifyField<float>(verifier, VT_THICKNESS, 4) &&
               verifier.EndTable();
    }
};

struct CircleRendererBuilder
{
    typedef CircleRenderer Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_enabled(bool enabled)
    {
        fbb_.AddElement<uint8_t>(CircleRenderer::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
    }
    void add_texture_path(::flatbuffers::Offset<::flatbuffers::String> texture_path)
    {
        fbb_.AddOffset(CircleRenderer::VT_TEXTURE_PATH, texture_path);
    }
    void add_color(const Konto::Serializable::Color* color)
    {
        fbb_.AddStruct(CircleRenderer::VT_COLOR, color);
    }
    void add_fade(float fade)
    {
        fbb_.AddElement<float>(CircleRenderer::VT_FADE, fade, 0.0f);
    }
    void add_thickness(float thickness)
    {
        fbb_.AddElement<float>(CircleRenderer::VT_THICKNESS, thickness, 0.0f);
    }
    explicit CircleRendererBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<CircleRenderer> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<CircleRenderer>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<CircleRenderer> CreateCircleRenderer(
    ::flatbuffers::FlatBufferBuilder& _fbb, bool enabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> texture_path = 0, const Konto::Serializable::Color* color = nullptr,
    float fade = 0.0f, float thickness = 0.0f)
{
    CircleRendererBuilder builder_(_fbb);
    builder_.add_thickness(thickness);
    builder_.add_fade(fade);
    builder_.add_color(color);
    builder_.add_texture_path(texture_path);
    builder_.add_enabled(enabled);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<CircleRenderer> CreateCircleRendererDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, bool enabled = false, const char* texture_path = nullptr,
    const Konto::Serializable::Color* color = nullptr, float fade = 0.0f, float thickness = 0.0f)
{
    auto texture_path__ = texture_path ? _fbb.CreateString(texture_path) : 0;
    return Konto::Serializable::CreateCircleRenderer(_fbb, enabled, texture_path__, color, fade, thickness);
}

inline bool VerifyComponent(::flatbuffers::Verifier& verifier, const void* obj, Component type)
{
    switch (type)
    {
    case Component_NONE: {
        return true;
    }
    case Component_Transform: {
        return verifier.VerifyField<Konto::Serializable::Transform>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    case Component_Camera: {
        return verifier.VerifyField<Konto::Serializable::Camera>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    case Component_SpriteRenderer: {
        auto ptr = reinterpret_cast<const Konto::Serializable::SpriteRenderer*>(obj);
        return verifier.VerifyTable(ptr);
    }
    case Component_CircleRenderer: {
        auto ptr = reinterpret_cast<const Konto::Serializable::CircleRenderer*>(obj);
        return verifier.VerifyTable(ptr);
    }
    default:
        return true;
    }
}

inline bool VerifyComponentVector(::flatbuffers::Verifier& verifier,
                                  const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values,
                                  const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyComponent(verifier, values->Get(i), types->GetEnum<Component>(i)))
        {
            return false;
        }
    }
    return true;
}

} // namespace Serializable
} // namespace Konto

#endif // FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_
