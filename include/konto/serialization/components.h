// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_
#define FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_

#include <flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 1 && FLATBUFFERS_VERSION_REVISION == 21,
              "Non-compatible flatbuffers version included");

namespace Konto
{
namespace Serializable
{

struct Vec3;

struct Color;

struct Transform;

struct Camera;

struct SpriteRenderer;

struct CircleRenderer;

enum Component : uint8_t
{
    Component_NONE = 0,
    Component_Transform = 1,
    Component_Camera = 2,
    Component_SpriteRenderer = 3,
    Component_CircleRenderer = 4,
    Component_MIN = Component_NONE,
    Component_MAX = Component_CircleRenderer
};

inline const Component (&EnumValuesComponent())[5]
{
    static const Component values[] = {Component_NONE, Component_Transform, Component_Camera, Component_SpriteRenderer,
                                       Component_CircleRenderer};
    return values;
}

inline const char* const* EnumNamesComponent()
{
    static const char* const names[6] = {"NONE", "Transform", "Camera", "SpriteRenderer", "CircleRenderer", nullptr};
    return names;
}

inline const char* EnumNameComponent(Component e)
{
    if (::flatbuffers::IsOutRange(e, Component_NONE, Component_CircleRenderer))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesComponent()[index];
}

template <typename T> struct ComponentTraits
{
    static const Component enum_value = Component_NONE;
};

template <> struct ComponentTraits<Konto::Serializable::Transform>
{
    static const Component enum_value = Component_Transform;
};

template <> struct ComponentTraits<Konto::Serializable::Camera>
{
    static const Component enum_value = Component_Camera;
};

template <> struct ComponentTraits<Konto::Serializable::SpriteRenderer>
{
    static const Component enum_value = Component_SpriteRenderer;
};

template <> struct ComponentTraits<Konto::Serializable::CircleRenderer>
{
    static const Component enum_value = Component_CircleRenderer;
};

bool VerifyComponent(::flatbuffers::Verifier& verifier, const void* obj, Component type);
bool VerifyComponentVector(::flatbuffers::Verifier& verifier,
                           const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values,
                           const ::flatbuffers::Vector<uint8_t>* types);

enum ProjectionType : int32_t
{
    ProjectionType_PERSPECTIVE = 0,
    ProjectionType_ORTHOGRAPHIC = 1,
    ProjectionType_MIN = ProjectionType_PERSPECTIVE,
    ProjectionType_MAX = ProjectionType_ORTHOGRAPHIC
};

inline const ProjectionType (&EnumValuesProjectionType())[2]
{
    static const ProjectionType values[] = {ProjectionType_PERSPECTIVE, ProjectionType_ORTHOGRAPHIC};
    return values;
}

inline const char* const* EnumNamesProjectionType()
{
    static const char* const names[3] = {"PERSPECTIVE", "ORTHOGRAPHIC", nullptr};
    return names;
}

inline const char* EnumNameProjectionType(ProjectionType e)
{
    if (::flatbuffers::IsOutRange(e, ProjectionType_PERSPECTIVE, ProjectionType_ORTHOGRAPHIC))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesProjectionType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS
{
  private:
    float x_;
    float y_;
    float z_;

  public:
    Vec3() : x_(0), y_(0), z_(0)
    {
    }
    Vec3(float _x, float _y, float _z)
        : x_(::flatbuffers::EndianScalar(_x)), y_(::flatbuffers::EndianScalar(_y)), z_(::flatbuffers::EndianScalar(_z))
    {
    }
    float x() const
    {
        return ::flatbuffers::EndianScalar(x_);
    }
    float y() const
    {
        return ::flatbuffers::EndianScalar(y_);
    }
    float z() const
    {
        return ::flatbuffers::EndianScalar(z_);
    }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS
{
  private:
    float r_;
    float g_;
    float b_;
    float a_;

  public:
    Color() : r_(0), g_(0), b_(0), a_(0)
    {
    }
    Color(float _r, float _g, float _b, float _a)
        : r_(::flatbuffers::EndianScalar(_r)), g_(::flatbuffers::EndianScalar(_g)), b_(::flatbuffers::EndianScalar(_b)),
          a_(::flatbuffers::EndianScalar(_a))
    {
    }
    float r() const
    {
        return ::flatbuffers::EndianScalar(r_);
    }
    float g() const
    {
        return ::flatbuffers::EndianScalar(g_);
    }
    float b() const
    {
        return ::flatbuffers::EndianScalar(b_);
    }
    float a() const
    {
        return ::flatbuffers::EndianScalar(a_);
    }
};
FLATBUFFERS_STRUCT_END(Color, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    int8_t padding0__;
    int16_t padding1__;
    Konto::Serializable::Vec3 scale_;
    Konto::Serializable::Vec3 rotation_;
    Konto::Serializable::Vec3 translation_;

  public:
    Transform() : enabled_(0), padding0__(0), padding1__(0), scale_(), rotation_(), translation_()
    {
        (void)padding0__;
        (void)padding1__;
    }
    Transform(bool _enabled, const Konto::Serializable::Vec3& _scale, const Konto::Serializable::Vec3& _rotation,
              const Konto::Serializable::Vec3& _translation)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))), padding0__(0), padding1__(0),
          scale_(_scale), rotation_(_rotation), translation_(_translation)
    {
        (void)padding0__;
        (void)padding1__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    const Konto::Serializable::Vec3& scale() const
    {
        return scale_;
    }
    const Konto::Serializable::Vec3& rotation() const
    {
        return rotation_;
    }
    const Konto::Serializable::Vec3& translation() const
    {
        return translation_;
    }
};
FLATBUFFERS_STRUCT_END(Transform, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Camera FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    uint8_t primary_;
    uint8_t fixed_aspect_ratio_;
    int8_t padding0__;
    float aspect_ratio_;
    float perspective_far_;
    float perspective_near_;
    float perspective_fov_;
    float orthographic_far_;
    float orthographic_near_;
    float orthographic_size_;
    int32_t projection_type_;

  public:
    Camera()
        : enabled_(0), primary_(0), fixed_aspect_ratio_(0), padding0__(0), aspect_ratio_(0), perspective_far_(0),
          perspective_near_(0), perspective_fov_(0), orthographic_far_(0), orthographic_near_(0), orthographic_size_(0),
          projection_type_(0)
    {
        (void)padding0__;
    }
    Camera(bool _enabled, bool _primary, bool _fixed_aspect_ratio, float _aspect_ratio, float _perspective_far,
           float _perspective_near, float _perspective_fov, float _orthographic_far, float _orthographic_near,
           float _orthographic_size, Konto::Serializable::ProjectionType _projection_type)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))),
          primary_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_primary))),
          fixed_aspect_ratio_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_fixed_aspect_ratio))), padding0__(0),
          aspect_ratio_(::flatbuffers::EndianScalar(_aspect_ratio)),
          perspective_far_(::flatbuffers::EndianScalar(_perspective_far)),
          perspective_near_(::flatbuffers::EndianScalar(_perspective_near)),
          perspective_fov_(::flatbuffers::EndianScalar(_perspective_fov)),
          orthographic_far_(::flatbuffers::EndianScalar(_orthographic_far)),
          orthographic_near_(::flatbuffers::EndianScalar(_orthographic_near)),
          orthographic_size_(::flatbuffers::EndianScalar(_orthographic_size)),
          projection_type_(::flatbuffers::EndianScalar(static_cast<int32_t>(_projection_type)))
    {
        (void)padding0__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    bool primary() const
    {
        return ::flatbuffers::EndianScalar(primary_) != 0;
    }
    bool fixed_aspect_ratio() const
    {
        return ::flatbuffers::EndianScalar(fixed_aspect_ratio_) != 0;
    }
    float aspect_ratio() const
    {
        return ::flatbuffers::EndianScalar(aspect_ratio_);
    }
    float perspective_far() const
    {
        return ::flatbuffers::EndianScalar(perspective_far_);
    }
    float perspective_near() const
    {
        return ::flatbuffers::EndianScalar(perspective_near_);
    }
    float perspective_fov() const
    {
        return ::flatbuffers::EndianScalar(perspective_fov_);
    }
    float orthographic_far() const
    {
        return ::flatbuffers::EndianScalar(orthographic_far_);
    }
    float orthographic_near() const
    {
        return ::flatbuffers::EndianScalar(orthographic_near_);
    }
    float orthographic_size() const
    {
        return ::flatbuffers::EndianScalar(orthographic_size_);
    }
    Konto::Serializable::ProjectionType projection_type() const
    {
        return static_cast<Konto::Serializable::ProjectionType>(::flatbuffers::EndianScalar(projection_type_));
    }
};
FLATBUFFERS_STRUCT_END(Camera, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpriteRenderer FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    int8_t padding0__;
    int16_t padding1__;
    Konto::Serializable::Color color_;
    float tiling_factor_;

  public:
    SpriteRenderer() : enabled_(0), padding0__(0), padding1__(0), color_(), tiling_factor_(0)
    {
        (void)padding0__;
        (void)padding1__;
    }
    SpriteRenderer(bool _enabled, const Konto::Serializable::Color& _color, float _tiling_factor)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))), padding0__(0), padding1__(0),
          color_(_color), tiling_factor_(::flatbuffers::EndianScalar(_tiling_factor))
    {
        (void)padding0__;
        (void)padding1__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    const Konto::Serializable::Color& color() const
    {
        return color_;
    }
    float tiling_factor() const
    {
        return ::flatbuffers::EndianScalar(tiling_factor_);
    }
};
FLATBUFFERS_STRUCT_END(SpriteRenderer, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CircleRenderer FLATBUFFERS_FINAL_CLASS
{
  private:
    uint8_t enabled_;
    int8_t padding0__;
    int16_t padding1__;
    Konto::Serializable::Color color_;
    float fade_;
    float thickness_;

  public:
    CircleRenderer() : enabled_(0), padding0__(0), padding1__(0), color_(), fade_(0), thickness_(0)
    {
        (void)padding0__;
        (void)padding1__;
    }
    CircleRenderer(bool _enabled, const Konto::Serializable::Color& _color, float _fade, float _thickness)
        : enabled_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))), padding0__(0), padding1__(0),
          color_(_color), fade_(::flatbuffers::EndianScalar(_fade)), thickness_(::flatbuffers::EndianScalar(_thickness))
    {
        (void)padding0__;
        (void)padding1__;
    }
    bool enabled() const
    {
        return ::flatbuffers::EndianScalar(enabled_) != 0;
    }
    const Konto::Serializable::Color& color() const
    {
        return color_;
    }
    float fade() const
    {
        return ::flatbuffers::EndianScalar(fade_);
    }
    float thickness() const
    {
        return ::flatbuffers::EndianScalar(thickness_);
    }
};
FLATBUFFERS_STRUCT_END(CircleRenderer, 28);

inline bool VerifyComponent(::flatbuffers::Verifier& verifier, const void* obj, Component type)
{
    switch (type)
    {
    case Component_NONE: {
        return true;
    }
    case Component_Transform: {
        return verifier.VerifyField<Konto::Serializable::Transform>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    case Component_Camera: {
        return verifier.VerifyField<Konto::Serializable::Camera>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    case Component_SpriteRenderer: {
        return verifier.VerifyField<Konto::Serializable::SpriteRenderer>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    case Component_CircleRenderer: {
        return verifier.VerifyField<Konto::Serializable::CircleRenderer>(static_cast<const uint8_t*>(obj), 0, 4);
    }
    default:
        return true;
    }
}

inline bool VerifyComponentVector(::flatbuffers::Verifier& verifier,
                                  const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values,
                                  const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyComponent(verifier, values->Get(i), types->GetEnum<Component>(i)))
        {
            return false;
        }
    }
    return true;
}

} // namespace Serializable
} // namespace Konto

#endif // FLATBUFFERS_GENERATED_COMPONENTS_KONTO_SERIALIZABLE_H_
